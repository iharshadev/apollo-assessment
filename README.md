# Apollo Back-End Engineering Challenge

This challenge is designed to evaluate several things:
 - How well you know Python
 - How effectively you can work with the Django framework
 - How well you understand different data serialization formats, which is important for working with the diverse APIs Apollo integrates with
 - Your ability to work with connected Django pages
 - Your ability to work with Django Rest Framework
 
It is intended to take 2-4 hours. After you submit your solution (either by emailing us a .tar or .zip file, or uploading to GitHub), we will schedule a call to talk through your solution and how it could be extended to accomplish further goals.
 
## Setting Up

Install Python 3.7 or later if it is not already installed. Then, set up and enter a virtual environment and run `pip install -r requirements.txt` to install the dependencies. You should then be able to run the project from the `exercise` directory by running `python manage.py runserver`.

To verify that the server is running correctly, visit `http:127.0.0.1:8000` in your browser.

## Challenge Guidelines

This Django project consists of two parts:
1. A very simple HTML page at `/connected/`.
2. A stubbed out API endpoint at `/api/converter/convert/`

Your tasks are to:
1. Add a file input to the HTML page and modify the view so that, when a file is submitted, convert it to JSON and return that to the user
2. Add the same functionality to the API endpoint, returning the converted JSON as an `application/json` response.

To test your solution, you can run `python manage.py test`. This will execute 3 tests, which attempt to submit a file and check the response.

A good solution will not only pass the tests, but also work on any user-submitted XML file.

### JSON Conversion

For the purposes of this exercise, you may ignore any XML attributes. We are only interested in converting the XML node tags and any text values into JSON.

Leaf nodes should be converted into a JSON object with the node tag as the key and the node's text value as the value. For example, `<Foo>Bar</Foo>` should be converted to `{"Foo": "Bar"}`.

Non-leaf nodes should be converted into a JSON object with the node name as the key and an array of the node's children as the value. For example:
```
<Foo>
    <Bar>Baz</Bar>
</Foo>
```
should be converted to
```javascript
{
    "Foo": [
        {"Bar": "Baz"}
    ]
}
```

The tests provide additional examples of more complex conversions.

<h1 align="center">Solution (Harsha's submission)</h1>

This implementation is supposed to serve as an improvement over that of the branch `xml-etree` in terms of transforming
 the XML file into a JSON object with the same structure/schema.

Loading the full contents of the entire XML file can get **overwhelming on system memory** as the size of the XML file grows.

One solution is to process the XML file in chunks/streams and roll this window until EOF is reached. Python's
 `xml.etree.ElementTree` offers the [Pull API](https://docs.python.org/3/library/xml.etree.elementtree.html#pull-api-for-non-blocking-parsing) for the same purpose 


>TL;DR: Used a stack based approach to propagate the schema from XML to a dictionary while reading the XML in multiple chunks
 
## XML Stream parsing

### The Pull API
1. Register events - start & end of tags
2. Feed data incrementally i.e. feed data as chunks read from the file in the request
3. Events are generated by the API every time it encounters an opening or a closing tag in the chunk that was fed.
    * These events can then be iterated over to form a JSON object
## [UPDATE]
The XML can be sequentially traversed using a moving window approach. Using a stack, the schema of the XML, can be propagated
to form a dictionary using the following algorithm. 

```bash
stack = []
foreach event, element in events:
    if event is start:
        push element into stack
    else:
        top_item := stack.pop()
        previous_item := stack.pop()
        if top_item[value] is a list:
            push element to previous_item[value]
        else :
            initialize previous_item[value] to [element]top_item
        push previous_item to stack
```
In summary, this algorithm does the following:
1. If event is start, push the element i.e. tag, value into stack
2. If event is end, push the latest item in stack one level below i.e.
    * pop the latest item and verify that the closing tag is correct
    * pop the stack again to get the parent tag of the current tag
    * push the current element into it's parent element making it a list of chilren elements
    
This algorithm is implemented as a method `buil()` in the class `StreamParser` in `/xml_converter/views.py`.
Each chunk of data read from the XML file in `request` is passed to this method until no chunks of data is left to read.
At the end of traversing the XML file chunk by chunk, the stack would be populated as a list with one dictionary where the 
key is the Root tag and the value is a the rest of the contents nested in the same manner as the XML file

Eg: The output of the `/connected/` API with `xml_converter/test_files/addresses.xml` as input is
```javascript
{
  "tag": "Root",
  "value": [
    {
      "tag": "Address",
      "value": [
        {
          "tag": "StreetLine1",
          "value": "123 Main St."
        },
        {
          "tag": "StreetLine2",
          "value": "Suite 400"
        },
        {
          "tag": "City",
          "value": "San Francisco"
        },
        {
          "tag": "State",
          "value": "CA"
        },
        {
          "tag": "PostCode",
          "value": "94103"
        }
      ]
    },
    {
      "tag": "Address",
      "value": [
        {
          "tag": "StreetLine1",
          "value": "400 Market St."
        },
        {
          "tag": "City",
          "value": "San Francisco"
        },
        {
          "tag": "State",
          "value": "CA"
        },
        {
          "tag": "PostCode",
          "value": "94108"
        }
      ]
    }
  ]
}
```

> Note: As it can be seen from the example, this algorithm at the moment outputs a JSON that is not **exactly** in the same format as what's expected in the example.
>**BUT** it maintains the XML schema is intact in the JSON after transformation

## Challenges
1. Since the data is read in chunks, there are some very intricate edge cases to account for
    * When a start event is raised, the text in the associated `Element` could be incomplete depending on how many bytes were
    read by the parser and how large the text in the said `Element` was - Have not encountered so far
    
### Comparison of approaches

Approach|Memory usage|Complexity|Flexibilty|Access to children nodes?|Schema derived?
---|---|---|---|---|---
ElementTree from string|High(entire XML file is read at once)|Linear - N (no. of leaf nodes)|Good|Yes|Yes
Pull API|Low(Part of the file is read at once)|Linear - N (no. of leaf nodes)|Poor - Need to explicitly maintain state to deduce certain conclusions|No|No
